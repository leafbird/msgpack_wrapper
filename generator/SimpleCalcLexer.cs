//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 SimpleCalc.g3 2014-03-18 00:00:15

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  AntlrTest 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class SimpleCalcLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int DIGIT=4;
	public const int DIV=5;
	public const int MINUS=6;
	public const int MULT=7;
	public const int NUMBER=8;
	public const int PLUS=9;
	public const int WHITESPACE=10;

	// delegates
	// delegators

	public SimpleCalcLexer()
	{
		OnCreated();
	}

	public SimpleCalcLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public SimpleCalcLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "SimpleCalc.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_DIV();
	partial void LeaveRule_DIV();

	// $ANTLR start "DIV"
	[GrammarRule("DIV")]
	private void mDIV()
	{
		EnterRule_DIV();
		EnterRule("DIV", 1);
		TraceIn("DIV", 1);
		try
		{
			int _type = DIV;
			int _channel = DefaultTokenChannel;
			// SimpleCalc.g3:9:5: ( '/' )
			DebugEnterAlt(1);
			// SimpleCalc.g3:9:7: '/'
			{
			DebugLocation(9, 7);
			Match('/'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DIV", 1);
			LeaveRule("DIV", 1);
			LeaveRule_DIV();
		}
	}
	// $ANTLR end "DIV"

	partial void EnterRule_MINUS();
	partial void LeaveRule_MINUS();

	// $ANTLR start "MINUS"
	[GrammarRule("MINUS")]
	private void mMINUS()
	{
		EnterRule_MINUS();
		EnterRule("MINUS", 2);
		TraceIn("MINUS", 2);
		try
		{
			int _type = MINUS;
			int _channel = DefaultTokenChannel;
			// SimpleCalc.g3:10:7: ( '-' )
			DebugEnterAlt(1);
			// SimpleCalc.g3:10:9: '-'
			{
			DebugLocation(10, 9);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MINUS", 2);
			LeaveRule("MINUS", 2);
			LeaveRule_MINUS();
		}
	}
	// $ANTLR end "MINUS"

	partial void EnterRule_MULT();
	partial void LeaveRule_MULT();

	// $ANTLR start "MULT"
	[GrammarRule("MULT")]
	private void mMULT()
	{
		EnterRule_MULT();
		EnterRule("MULT", 3);
		TraceIn("MULT", 3);
		try
		{
			int _type = MULT;
			int _channel = DefaultTokenChannel;
			// SimpleCalc.g3:11:6: ( '*' )
			DebugEnterAlt(1);
			// SimpleCalc.g3:11:8: '*'
			{
			DebugLocation(11, 8);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MULT", 3);
			LeaveRule("MULT", 3);
			LeaveRule_MULT();
		}
	}
	// $ANTLR end "MULT"

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 4);
		TraceIn("PLUS", 4);
		try
		{
			int _type = PLUS;
			int _channel = DefaultTokenChannel;
			// SimpleCalc.g3:12:6: ( '+' )
			DebugEnterAlt(1);
			// SimpleCalc.g3:12:8: '+'
			{
			DebugLocation(12, 8);
			Match('+'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS", 4);
			LeaveRule("PLUS", 4);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_NUMBER();
	partial void LeaveRule_NUMBER();

	// $ANTLR start "NUMBER"
	[GrammarRule("NUMBER")]
	private void mNUMBER()
	{
		EnterRule_NUMBER();
		EnterRule("NUMBER", 5);
		TraceIn("NUMBER", 5);
		try
		{
			int _type = NUMBER;
			int _channel = DefaultTokenChannel;
			// SimpleCalc.g3:32:9: ( ( DIGIT )+ )
			DebugEnterAlt(1);
			// SimpleCalc.g3:32:11: ( DIGIT )+
			{
			DebugLocation(32, 11);
			// SimpleCalc.g3:32:11: ( DIGIT )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>='0' && LA1_1<='9')))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// SimpleCalc.g3:
					{
					DebugLocation(32, 11);
					input.Consume();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NUMBER", 5);
			LeaveRule("NUMBER", 5);
			LeaveRule_NUMBER();
		}
	}
	// $ANTLR end "NUMBER"

	partial void EnterRule_WHITESPACE();
	partial void LeaveRule_WHITESPACE();

	// $ANTLR start "WHITESPACE"
	[GrammarRule("WHITESPACE")]
	private void mWHITESPACE()
	{
		EnterRule_WHITESPACE();
		EnterRule("WHITESPACE", 6);
		TraceIn("WHITESPACE", 6);
		try
		{
			int _type = WHITESPACE;
			int _channel = DefaultTokenChannel;
			// SimpleCalc.g3:34:12: ( ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+ )
			DebugEnterAlt(1);
			// SimpleCalc.g3:34:14: ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+
			{
			DebugLocation(34, 14);
			// SimpleCalc.g3:34:14: ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if (((LA2_1>='\t' && LA2_1<='\n')||(LA2_1>='\f' && LA2_1<='\r')||LA2_1==' '))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// SimpleCalc.g3:
					{
					DebugLocation(34, 14);
					input.Consume();


					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(34, 57);
			 _channel = Hidden; 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHITESPACE", 6);
			LeaveRule("WHITESPACE", 6);
			LeaveRule_WHITESPACE();
		}
	}
	// $ANTLR end "WHITESPACE"

	partial void EnterRule_DIGIT();
	partial void LeaveRule_DIGIT();

	// $ANTLR start "DIGIT"
	[GrammarRule("DIGIT")]
	private void mDIGIT()
	{
		EnterRule_DIGIT();
		EnterRule("DIGIT", 7);
		TraceIn("DIGIT", 7);
		try
		{
			// SimpleCalc.g3:36:17: ( '0' .. '9' )
			DebugEnterAlt(1);
			// SimpleCalc.g3:
			{
			DebugLocation(36, 17);
			if ((input.LA(1)>='0' && input.LA(1)<='9'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("DIGIT", 7);
			LeaveRule("DIGIT", 7);
			LeaveRule_DIGIT();
		}
	}
	// $ANTLR end "DIGIT"

	public override void mTokens()
	{
		// SimpleCalc.g3:1:8: ( DIV | MINUS | MULT | PLUS | NUMBER | WHITESPACE )
		int alt3=6;
		try { DebugEnterDecision(3, false);
		switch (input.LA(1))
		{
		case '/':
			{
			alt3 = 1;
			}
			break;
		case '-':
			{
			alt3 = 2;
			}
			break;
		case '*':
			{
			alt3 = 3;
			}
			break;
		case '+':
			{
			alt3 = 4;
			}
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			{
			alt3 = 5;
			}
			break;
		case '\t':
		case '\n':
		case '\f':
		case '\r':
		case ' ':
			{
			alt3 = 6;
			}
			break;
		default:
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
		}

		} finally { DebugExitDecision(3); }
		switch (alt3)
		{
		case 1:
			DebugEnterAlt(1);
			// SimpleCalc.g3:1:10: DIV
			{
			DebugLocation(1, 10);
			mDIV(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// SimpleCalc.g3:1:14: MINUS
			{
			DebugLocation(1, 14);
			mMINUS(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// SimpleCalc.g3:1:20: MULT
			{
			DebugLocation(1, 20);
			mMULT(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// SimpleCalc.g3:1:25: PLUS
			{
			DebugLocation(1, 25);
			mPLUS(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// SimpleCalc.g3:1:30: NUMBER
			{
			DebugLocation(1, 30);
			mNUMBER(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// SimpleCalc.g3:1:37: WHITESPACE
			{
			DebugLocation(1, 37);
			mWHITESPACE(); 

			}
			break;

		}

	}


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

	#endregion

}

} // namespace  AntlrTest 
